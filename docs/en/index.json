[
{
	"uri": "https://kajahno.me/bash-notes/en/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Basics Covers the fundamental concepts used when working within bash (applicable to other shells)\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/1.introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " The GNU Bourne-Again SHell is a very popular shell that combines functionalities for both programming and interactive use.\nOther shells  C shell - csh KornShell - ksh Bourne shell - sh Z shell - zsh with Oh-my-zsh Debian Almquist shell - dash  What is a \u0026lsquo;shell\u0026rsquo; then? It\u0026rsquo;s a program that receives input from the keyboard and forwards them to the operating system. It was the first kind of user interface used.\nWhat is a \u0026lsquo;terminal [emulator]\u0026lsquo;? Nowadays, most operating systems provide a Graphical User Interface (GUI). A terminal emulator is a program that lets you interact with a shell. Examples include: gnome-terminal, terminator.\nStarting bash Assumming you\u0026rsquo;re in an operating system that has a GUI, just open your favorite terminal emulator and type:\n$ bash  Printing the version of bash:\n$ bash --version GNU bash, version 4.3.48(1)-release (x86_64-pc-linux-gnu) Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software; you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.  Modes of execution In bash you can either type commands and run them immediately (interactive), or place them in a file and then run as a batch of commands (also known as a bash script)\nInteractive Print the working directory:\n$ pwd /home/vagrant  list the files and directories in current directory:\n$ ls  Non-interactive (bash script) Create a file (named myfile) and place the following content in it:\npwd ls  Run that file using bash\n$ bash myfile /home/vagrant myfile  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/2.io-redirection/",
	"title": "IO Redirection",
	"tags": [],
	"description": "",
	"content": " graph LR; inp[stdin] -- p(program) p -- stdout[stdout] p -- stderr[stderr] classDef middle stroke:#333,stroke-width:4px; classDef edge fill:#fff,stroke:#333,stroke-width:0px; class p middle; class inp edge; class stdout edge; class stderr edge;  By convention any shell opens three file descriptors when a program is run:\n Standard input (stdin): feeds the program with data Standard output (stdout): normally prints messages in the terminal Standard error (stderr): normally prints error messages in the terminal (when things fail)  These three file descriptors are referred as non-negative integers (defined by the POSIX standard):\n stdin: 0 stdout: 1 (this is the default) stderr: 2  A very powerful feature of bash (and other shells) is input and output redirection. If no redirection is specified, by default all three file descriptors are connected to the terminal (so the information will be displayed)\nRun program with no redirection $ ls -l total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Redirect standard output $ ls -l 1\u0026gt; output  As you see, nothing was printed. The output has been redirected to the file output. If we print the content of this file we\u0026rsquo;ll see that indeed the output is there:\n$ cat output total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Since the file descriptor 1 is the default file descriptor in bash, we can simple run the following and achieve the same result:\n$ ls -l \u0026gt;output $ cat output total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Redirect standard error To redirect the standard error, we first need to create an error:\n$ ls --bad-usage ls: unrecognized option '--bad-usage' Try 'ls --help' for more information.  As you see, that option --bad-usage doesn\u0026rsquo;t really form part of the command ls. However, because by default everything is redirected to the terminal, we also see the stderr output.\nLet\u0026rsquo;s redirect that to a new file:\n$ ls --bad-usage 2\u0026gt; error_output  Notice how there was nothing printed to the terminal, however by inspecting the content of the file we can confirm that indeed we have successfully redirected stderr:\n$ cat error_output ls: unrecognized option '--bad-usage' Try 'ls --help' for more information.  Redirect stdout and stderr We can combine both output redirections in a single line:\n$ ls -l output non-existing-file \u0026gt;newoutput 2\u0026gt;newerr  Nothing will get printed in the terminal. However by inspecting the content of those two new files newoutput and newerr we can confirm that the redirection took place:\n$ cat newoutput -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output $ cat newerr ls: cannot access 'non-existing-file': No such file or directory  Combine stdout and stderr Sometimes is pretty convenient to redirect both stdout and stderr a single file. This can be achieved with:\n$ ls -l output non-existing-file \u0026gt;combined-output 2\u0026gt;\u0026amp;1  In this case we are explicitly telling bash to combine (or pipe) stderr into stdout. Inspecting the new file:\n$ cat combined-output ls: cannot access 'non-existing-file': No such file or directory -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output  A shorthand for this syntax is: ls -l output non-existing-file \u0026amp;\u0026gt;combined-output\n Redirect stdin For this we need to make sure the program we use supports stdin.\nThe program wc prints words, lines, and the byte count of the specified input. For example:\n$ wc combined-output 2 18 118 combined-output  wc is using the input file specified as argument. Running wc with no arguments, and typing manually:\n$ wc this is a test second line [CRTL+d] 2 6 27  Will produce the output base on what was specified in stdin. We use CRTL+d to indicate the end of input. In this occasion, of course, wc is reading directly from stdin.\nNow if we were to redirect stdin, and specify a file as input instead of manually typing the content, we can by running:\n$ wc \u0026lt;combined-output 2 18 118  Redirect stdin with a heredoc When redirecting stdin we also have a way to explicitly specify the input, with a custom delimiter (not the interactive CTRL-d)\nThis can be achieved with the following:\n$ wc \u0026lt;\u0026lt;delimiter \u0026gt; this is a test \u0026gt; with a custom delimiter \u0026gt; delimiter 2 8 39  In this case the delimiter will only act as such if it\u0026rsquo;s the only word in a line of input. This way of redirecting is called here document or heredoc.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/reference/",
	"title": "Command reference",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Command reference Covers a list of commands and what they do\n io-redirection   "
},
{
	"uri": "https://kajahno.me/bash-notes/en/reference/io-redirection/",
	"title": "io-redirection",
	"tags": [],
	"description": "",
	"content": "Commands related to input and output\n   Command Description     PROGRAM \u0026gt;stdout redirect standard output of program to file stdout   PROGRAM 2\u0026gt;stderr redirect standard error output of program to file stderr   PROGRAM \u0026gt;combined 2\u0026gt;\u0026amp;1 redirect stderr and stdout outputs of program to file combined   PROGRAM \u0026amp;\u0026gt;combined redirect stderr and stdout outputs of program to file combined   PROGRAM \u0026lt; combined reads file combined and sends it as input to the program    "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/3.shell-pipelines/",
	"title": "Shell Pipelines",
	"tags": [],
	"description": "",
	"content": " graph LR; stdout1 -- PIPE -- inp2 subgraph program one inp1[stdin] -- p1(program) p1 -- stdout1[stdout] p1 -- stderr1[stderr] stderr1 -. optional .- stdout1 end subgraph program two inp2[stdin] -- p2(program) p2 -- stdout2[stdout] p2 -- stderr2[stderr] end classDef middle stroke:#333,stroke-width:4px; classDef edge fill:#ffffde,stroke:#333,stroke-width:0px; class p middle; class inp1 edge; class inp2 edge; class stdout1 edge; class stderr1 edge; class stdout2 edge; class stderr2 edge;  Some shells such as bash provide the ability of chaining program commands together. The way it works is that the standard output of one program as input to another program, all chained together by using the pipe (|) character.\nPrint content of a file and calculate word count This can be done with the following command:\n$ cat ~/.profile | wc 20 99 655  As we see, the output of the file ~/.profile has been redirected as input to the program wc\nList files redirecting stderr and calculate word count $ ls combined-output non-existent 2\u0026gt;\u0026amp;1 | wc -l 2  Regardless of both files existing or not, our output will show the same count since we have redirected stderr to stdout.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/4.job-management/",
	"title": "Job Management",
	"tags": [],
	"description": "",
	"content": " When running programs in bash, it\u0026rsquo;s possible to do it in a \u0026lsquo;detached\u0026rsquo; mode. That is, sending the job to the background and continuing using the terminal\nIn order to prepare for this, let\u0026rsquo;s create the plain file long-time with the following content in it:\necho 'process started' sleep 60 #time in seconds echo 'process ended'  You can run this file by doing:\n$ bash long-time  The downside is that it will take around 60 seconds, time in which the terminal will be busy and cannot be used.\nSend jobs to the background Just append an ampersand to the end of the command:\n$ bash long-time \u0026amp; [1] 1718  The good thing is that now we can keep using the terminal since the job is executing in the background. This can be confirmed by running:\n$ jobs [1]+ Running bash long-time \u0026amp;  Something you\u0026rsquo;ll notice is that even though the program is running in the background, the output is being redirected to the terminal. Of course, we can redirect it as well.\nSimilarly we can end or kill jobs that are in the background, as follows:\n$ kill %1 $ [1]+ Terminated bash long-time  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/5.bash-options/",
	"title": "Bash options",
	"tags": [],
	"description": "",
	"content": " Running a bash script has some interesting options that are worth mentioning. Let\u0026rsquo;s explore them here.\nIn order to prepare for this, let\u0026rsquo;s create the plain file script1 with the following content in it:\necho 'process started' ls non-existing sleep 10 #time in seconds touch somefile ls -l somefile echo 'process ended'  Check for syntax validity $ bash -n script1  When nothing is printed, the syntax is fine\nOutput commands as they\u0026rsquo;re being read Using verbose flag:\n$ bash -v script1 echo 'process started' process started ls non-existing ls: cannot access 'non-existing': No such file or directory sleep 10 #time in seconds touch somefile ls -l somefile -rw-rw-r-- 1 vagrant vagrant 0 Nov 24 23:06 somefile echo 'process ended' process ended  Notice how the comment is also being printed\n Using the -x flag:\n$ bash -x script1 + echo 'process started' process started + ls non-existing ls: cannot access 'non-existing': No such file or directory + sleep 10 + touch somefile + ls -l somefile -rw-rw-r-- 1 vagrant vagrant 0 Nov 24 23:08 somefile + echo 'process ended' process ended  It shows every line being executed. Also arguably more readable than a plain -v. Notice how the comment is being ignored\n "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/6.decision-making/",
	"title": "Decision Making",
	"tags": [],
	"description": "",
	"content": " Making decisions help our scripts to have better flow control and add additionally robustness and avoid repetition.\nInline syntax This syntax is composed of two operators: and (\u0026amp;\u0026amp;) and or ||\nAnd (\u0026amp;\u0026amp;) case Run a command and run another one if the former was successful:\n$ ls \u0026amp;\u0026amp; echo 'yay, command was successful' combined-output long-time newerr output somefile error_output myfile newoutput script1  As shown before, of course we can redirect stdout of the former command:\n$ ls 1\u0026gt;/dev/null \u0026amp;\u0026amp; echo 'yay, command was successful' yay, command was successful  redirecting to /dev/null basically means that we\u0026rsquo;re discarding the output\n Or (||) case Run a command and run another one if the former failed:\n$ ls /nonexistent || echo 'partition /nonexistent does not exist' ls: cannot access '/nonexistent': No such file or directory partition /nonexistent does not exist  As shown before, of course we can redirect stderr of the former command:\n$ ls /nonexistent 2\u0026gt;/dev/null || echo 'partition /nonexistent does not exist' partition /nonexistent does not exist  Combining \u0026amp;\u0026amp; and || Sometimes is useful to run a command when another one is successful, and another one when it fails.\nFor example consider the following command:\n$ cd /tmp \u0026amp;\u0026amp; echo 'command succeeded, removing old files' || echo 'command failed, aborting' command succedded  In case it succeeds we could perform some housekeeping operation and remove old logs. On the other hand if the command failed we would most likely want to abort and exit\nOf course at this point we have only echoes so nothing is actually done. If we were to perform this sort of housekeeping using these operators it would be something similar to:\n Case of success\n$ cd /tmp \u0026amp;\u0026amp; { echo 'command succeeded, removing old files' \u0026amp;\u0026amp; find -type f -mtime +2 -delete \u0026amp;\u0026amp; echo 'files removed';} || { echo 'command failed, aborting';} command succeeded, removing old files files removed  Case of failure\n$ cd /tmp2 \u0026amp;\u0026amp; { echo 'command succeeded, removing old files' \u0026amp;\u0026amp; find -type f -mtime +2 -delete \u0026amp;\u0026amp; echo 'files removed';} || echo 'command failed, aborting' -bash: cd: /tmp2: No such file or directory command failed, aborting   As you can see to perform this operation, things start to get fiddly. In order to group decisions we would need to envelop them in curly braces, and to make things worse, the closing curly brace must have a semicolon just before. Please do not use this as a reference to write long bash scripts. Your future self will appreciate when you have to change and old script without all these conditions in it.\n The command find -type f -mtime +2 -delete means: find files only with more than 2 days older and delete them\n Extended syntax Using last example as a reference, let\u0026rsquo;s refactor using an if statement:\nif cd /tmp then echo 'command succeeded, removing old files' if find -type f -mtime +2 -delete; then echo 'files removed' else echo 'files failed to remove' fi else echo 'command failed, aborting' fi command succeeded, removing old files files removed  A couple of things to notice here:\n the first line of the if statement can have the then next, provided that it\u0026rsquo;s specified as a separate command (using semicolon) syntax is super clear and easier to maintain there is a bit of repetition in the case of failure After the then we don\u0026rsquo;t really need a newline or separator, so this would work just fine: if CONDITION; then echo 'something; fi  Using the syntax if TEST; then as an example. What goes in between if and then is called a \u0026lsquo;test command\u0026rsquo;. The amount of test commands in Bash could be intimidating at first, but once you get the hang of it, they make a lot of sense and are easy to remember. A list of those can be found in here.\nAs an extended example here\u0026rsquo;s how to ask for another condition just before the default else:\nif cd /tmp2 then echo 'command succeeded, removing old files' if find -type f -mtime +2 -delete; then echo 'files removed' else echo 'files failed to remove' fi elif cd /tmp then echo 'second command succeeded' else echo 'command failed, aborting' fi -bash: cd: /tmp2: No such file or directory second command succeeded  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/7.success-or-failure/",
	"title": "Success of Failure",
	"tags": [],
	"description": "",
	"content": " In previous examples we\u0026rsquo;ve referred to \u0026lsquo;success\u0026rsquo; or \u0026lsquo;failure\u0026rsquo; when running commands within bash. This is closely related to the return codes of the programs we call in our commands. To find what was the return code of a particular program, just access the magic variable $? after invoking the program.\nFor this section create a file named return-codes and put the following content it in:\nif [ $1 == 'success' ] then echo 'success' exit 0 else echo 'failure' \u0026gt;\u0026amp;2 exit 1 fi  The $1 is making reference to the first argument passed to the bash script at invocation\n What is \u0026lsquo;success\u0026rsquo; then? It\u0026rsquo;s when a program returns a return code of 0.\nFor example:\n$ echo hi there hi there $ echo $? 0  Now using our little script:\n$ bash return-codes success success $ echo $? 0  And what about \u0026lsquo;failure\u0026rsquo;? It\u0026rsquo;s when a program returns a non-zero return code.\nFor example:\n$ ls non-existent ls: cannot access 'non-existent': No such file or directory $ echo $? 2  And using our script:\n$ bash return-codes fail fail $ echo $? 1  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/8.variables/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": " In bash and many other programming languages, a variable is a container where we can store values and reference/modify them later on.\nVariable names Must begin with alphanumeric character or underscore, and end with one or more alphanumeric or underscore characters.\nBy convention bash variables tend to be in uppercase, however that depends on the style of programming. Personally I tend to name variables in upper case when they are in a global scope (at the beginning of a script) , and in lowercase when in local scope (inside a function or statement).\nDeclaring a variable Let\u0026rsquo;s create a couple of variables. Run the following:\nVAR1=\u0026quot;some value\u0026quot; var1=\u0026quot;some other value\u0026quot; var4='some other value with singlequotes' var_with_underscores=\u0026quot;some value with underscores: ___\u0026quot; var_with_no_spaces=this_val_with-no-spaces  In the above it\u0026rsquo;s good to point out:\n Variable names are case sensitive (just like file names in Linux) There is no space whatsoever when assigning a value to a variable (e.g. wrong declarations include -\u0026gt; var= \u0026quot;some val\u0026quot;, var = \u0026quot;some val\u0026quot;, var =\u0026quot;some val\u0026quot;) Variables must not start with numbers Variables that have spaces as value will need quotes around them (either single or double) Variables that do not have spaces as values do not need quotes  Accessing a variable Just specify the name of the variable, preceded by dollar sign ($):\n$ echo $VAR1 some value $ echo $var1 some other value $ echo $var4 some other value with singlequotes $ echo $var_with_underscores some value with underscores: ___ $ echo $var_with_no_spaces this_val_with-no-spaces  Now this approach is normally fine when printing a single variable, but not so useful when concatenating:\n two variables together -\u0026gt; $VAR1$var1 a variable with a string -\u0026gt; \\$VAR1somestring  For these cases the best practice is to envelop the name of the variable within curly braces:\n$ echo ${VAR1}${var1} some valuesome other value $ echo ${VAR1}s, because life is boring with a single value some values, because life is boring with a single value  Now in that second example, since the value we\u0026rsquo;re printing contains spaces (and it\u0026rsquo;s perfectly supported by echo), it\u0026rsquo;s a good practice to envelop everything in double quotes:\n$ echo \u0026quot;${VAR1}s, because life is boring with a single value\u0026quot; some values, because life is boring with a single value  Note that if single quotes were used instead, the value of the variable would not get substituted as almost always wanted:\n$ echo '${VAR1}s, because life is boring with a single value' ${VAR1}s, because life is boring with a single value  Variable as commands Let\u0026rsquo;s put a command as the content of a variable:\ncustom_ls=\u0026quot;ls -lrt\u0026quot;  Then if you just expand the value of that variable in the shell:\n$ $custom_ls total 32 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output [...]  Propagate variable across subshells A subshell is when bash is invoked from within bash (either explicitly or implicitly), for example: $ bash will return a subshell\n All the variables that we declare, by default will not get propagated to child subshells. This is particularly annoying if we call bash scripts that are expecting some variables to be already defined.\nExample of variable not getting propagated to a subshell:\n$ localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ bash $ echo $localvar $ exit $ echo $localvar 42 is a great number  In order to make a variable get propagated to subshells, we must first export it:\n$ localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ export localvar $ bash $ echo $localvar 42 is a great number  Notice how the export command does not have a dollar sign\n We can also export and define the variable in one go:\n$ export localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ bash $ echo $localvar 42 is a great number  Another way to export variables is by using the command declare with the -x flag:\n$ declare -x localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ bash $ echo $localvar 42 is a great number  Going back to the example where we want to pass a specific variable for the duration of the script, we can pass an ephemeral variable like this:\n Create a file script2 with the following content:\necho \u0026quot;Value passed is: $ephemeral_var\u0026quot;  Give the file execution permissions\n$ chmod +x script2  Run script without specifying the variable\n$ ./script2 Value passed is:  Specify the variable only for the duration of that script\n$ ephemeral_var=\u0026quot;42, of course\u0026quot; ./script2 Value passed is: 42, of course   String substitution Assuming we have the following variable:\n$ myvar=\u0026quot;todo muy muy bien\u0026quot;   Removing trailing strings: if we were to remove the word bien from right to left, we can simply do:\n$ echo \u0026quot;${myvar%bien}\u0026quot; todo muy muy  Removing trailing pattern (shell matching file patterns):\n single character (? matches any one character): remove last character\n$ echo \u0026quot;${myvar%?}\u0026quot; todo muy muy bie  many characters (* matches zero or more characters): remove everything after the m\n$ echo \u0026quot;${myvar%m*}\u0026quot; todo muy  many characters (* matches zero or more characters): remove everything after the m, make sure it\u0026rsquo;s largest possible match of character m\n$ echo \u0026quot;${myvar%%m*}\u0026quot; todo  rename filename extension: from .jpg to .png\n$ imagename=photo1.jpg $ echo \u0026quot;${imagename%.jpg}.png\u0026quot; photo1.png  extract path from absolute path to filename /home/vagrant/mydir/myfile.txt\n$ filename=/home/vagrant/mydir/myfile.txt $ echo \u0026quot;path is '${filename%/*}'\u0026quot; path is '/home/vagrant/mydir'  Note: the bash command dirname does exactly this\n  Removing leading pattern (shell matching file patterns):\n single character (? matches any one character): remove first character\n$ echo \u0026quot;${myvar#?}\u0026quot; odo muy muy bien  many characters (* matches zero or more characters): remove everything before the m\n$ echo \u0026quot;${myvar#*m}\u0026quot; uy muy bien  many characters (* matches zero or more characters): remove everything before the m, make sure it\u0026rsquo;s largest possible match of character m\n$ echo \u0026quot;${myvar##*m}\u0026quot; uy bien  parse username and host parts from string john@10.0.0.20\n$ conn_str=\u0026quot;john@10.0.0.20\u0026quot; $ host=\u0026quot;${conn_str%*@}\u0026quot; $ echo $host 10.0.0.20 $ username=\u0026quot;${conn_str%@*}\u0026quot; $ echo $username john  extract filename from absolute path to filename /home/vagrant/mydir/myfile.txt\n$ filename=/home/vagrant/mydir/myfile.txt $ echo \u0026quot;filename is '${filename##*/}'\u0026quot; filename is 'myfile.txt'  Note: the bash command basename does exactly this.\n  Replacing pattern from middle of string:\n Replace bien for bueno in string muy muy bien\n$ echo \u0026quot;${myvar/bien/bueno}\u0026quot; todo muy muy bueno  Note: there\u0026rsquo;s a very powerful bash program called sed that does this and much more\n   Substrings Let\u0026rsquo;s declare the following variable:\nsubstrvar=\u0026quot;variable with dummy content\u0026quot;  Now let\u0026rsquo;s do a couple of cool things to this variable:\n Extracting the \u0026lsquo;variable\u0026rsquo; word:\n$ echo ${substrvar:0:8} variable  The starting index goes in the middle (starting from 0), then the length of the string goes at the third place\n  Extracting everything after the \u0026lsquo;variable\u0026rsquo; word:\n$ echo $(substrvar:8) with dummy content  Notice how the second index is optional and by default will return all the remaining characters of the string\n   Special variables  Return value of command ran: stored in $? Current prompt: $PS1 Current path (where all the programs that can be run are located): $PATH Home directory: $HOME  More information about variables is in here\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/9.bash-scripts/",
	"title": "Bash scripts",
	"tags": [],
	"description": "",
	"content": " Bash scripts enable us to reutilize a set of commands and provide robustness on our daily actions. Knowing this is a must for doing any kind of automation using bash.\nAccessing parameters Consider the following script:\n create a file params1.bash and place the content in:\necho $0 echo $1 echo $2  change the permissions and run it:\n$ chmod +x params1.bash $ ./params1.bash one ./script1.bash one   As you can see the parameter $0 corresponds to the name of the script, and any other command line parameter is enumerated from $1 onwards.\nDifference between command line parameter, argument, and option thanks to this fellow\n Accessing all parameters  create a file params2.bash and place the following content inside:\necho $# echo $* echo $@  change permissions and run it with some params:\n$ chmod +x params2.bash $ ./params2.bash one two three 3 one two three one two three   As you see:\n $#: counts how many arguments were passed $*: provides all arguments $@: provides all arguments  Now, even though in both $* and $@ we appear to have the same result, there\u0026rsquo;s a subtle difference. Let\u0026rsquo;s modify our script to call another script as see what\u0026rsquo;s going on:\n Create another script params3.bash with the following content:\necho \u0026quot;number of args: $#\u0026quot;  Give it execution permissions\n$ chmod +x params3.bash  Now edit the params2.bash with the following content:\necho $# ./params3.bash $* ./params3.bash $@ ./params3.bash \u0026quot;$*\u0026quot; ./params3.bash \u0026quot;$@\u0026quot;  Run it with a particular set of params and observe the result:\n$ ./params2.bash one two three \u0026quot;and four\u0026quot; 4 number of args: 5 number of args: 5 number of args: 1 number of args: 4   Sure enough those results might not be what you expected. Let\u0026rsquo;s go case by case:\n ./params3.bash $*: sent the following args -\u0026gt; one two three and four ./params3.bash $@: sent the following args -\u0026gt; one two three and four ./params3.bash \u0026quot;$*\u0026quot;: sent the following args -\u0026gt; \u0026ldquo;one two three and four\u0026rdquo; ./params3.bash \u0026quot;$@\u0026quot;: sent the following args -\u0026gt; \u0026lsquo;one two three \u0026ldquo;and four\u0026rdquo;\u0026rsquo;  Normally the intended thing we want to do, which is to forward all arguments, is accomplished in the last case. We are going to see more of this when covering arrays.\nread command This command allows us to promp for an input value and store it in a variable. For example:\n$ read VAR something $ echo $VAR something  You can also specify a prompt message, for example:\n$ read -p \u0026quot;What is your age? \u0026quot; age What is your age? can't say $ echo $age can't say  It\u0026rsquo;s also possible to specify multiple parameters at once:\n$ read one two this is a test $ echo $one this $ echo $two is a test  This command reads the arguments separated by space\n "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/10.flow-control/",
	"title": "Flow control",
	"tags": [],
	"description": "",
	"content": " Flow control expressions allow us to include additional logic into our bash scripts\nFor loop Looping over stdin Let\u0026rsquo;s create the simplest for loop in a script:\n create a file simpleforloop.bash and place the following content inside:\nfor VAR do echo Hey $VAR done  change the permissions and run it:\n$ chmod +x simpleforloop.bash $ ./simpleforloop.bash one two three Hey one Hey two Hey three $   If no list of values is specified to the for loop, then stdin will be used as default. It\u0026rsquo;s important to note that the commands within the do and done statement will be run for each value specified in the list (each value in stdin in this case).\nIn this example the variable used was VAR, however this doesn\u0026rsquo;t really matter since it\u0026rsquo;s just a container for the iteration variable\n Looping over a list This is by far the most common way of using a for loop in bash\nRun the following command directly in the shell:\nfor i in $( ls ); do echo Hey $i done  It\u0026rsquo;s interesting to point out that:\n The output (cropped) should be something similar to:\nHey combined-output [...] Hey simpleforloop.bash Hey somefile  We are passing list of values to the for loop: we\u0026rsquo;re gathering the result of running the command ls in a subshell\n Each value from the list is assigned to the iteration variable i\n The do statement was placed inline. This could have also been specified in a new line\n In this case we have only one statement in the loop, echo Hey $1, however we can have as many as we wanted (including, other loops, of course)\n  Classic C-like for loop in bash If you\u0026rsquo;re familiar with C-like loops, then this should feel natural. If not, in case you bumped into this you\u0026rsquo;ll know.\nRun the following script directly in the shell:\nfor ((i=1; i\u0026lt;10; i++)); do echo Hey $i done  Things to point out:\n The output (cropped) should be similar to:\nHey 1 [...] Hey 9  Bash automatically assigns the iteration variable for i\n We can control the increment of the looping variable: instead of i++, we can easily say i+=2 to increment by 2 after every loop\n  Looping over the characters of a string variable Run the following in the shell:\nvar=\u0026quot;Portuguese and Spanish have roughly 90% of lexical similarity\u0026quot; for ((i=0; i\u0026lt;${#var}; i++ )) do echo character[${i}] = ${var:i:1} done  Things to point out:\n The output (cropped) should be similar to:\ncharacter[0] = P character[1] = o character[2] = r [...] character[59] = t character[60] = y  Pay close attention on how we got the character count of the string: ${#var}\n  This is just for fun, handling complicated things like this in bash is probably a bad idea.\n Bonus: print the string characters in reverse order Simple but not straightforward, the following will accomplish the challenge:\nvar=\u0026quot;Portuguese and Spanish have roughly 90% of lexical similarity\u0026quot; for ((i=${#var} - 1; i\u0026gt;=0; i-- )); do echo character[${i}] = ${var:i:1} done  The output should be similar to:\ncharacter[60] = y character[59] = t [...] character[1] = o character[0] = P  While loop Differs from a for loop in the sense that it will continue looping while a condition remains true (basically non-zero) . For example, let\u0026rsquo;s run the following in the shell:\ni=0 while (( i \u0026lt; 10 )) do echo Hey $i i=$((i+1)) done  Things to notice:\n The output should be similar to:\nHey 0 Hey 1 [...] Hey 9  There\u0026rsquo;s a strange $(( )), this is called arithmetic expression and will get covered in the next section\n It\u0026rsquo;s very similar to a for loop\n  Looping over the result of a pipeline of commands Let\u0026rsquo;s say, we want to loop over the result of ls using a while loop. We can achieve it with:\nls | while read fname; do echo Hey file: $fname done  Things to notice here:\n The output should be similar to:\nHey file: combined-output [...] Hey file: somefile  The while condition relies in the read command, which parses each output of the ls\n  Until loop There\u0026rsquo;s another loop, the until loop. It\u0026rsquo;s syntax is similar to the while loop but differs in the sense that the loop will continue until the condition is met (think of it as \u0026lsquo;while the condition is not true\u0026rsquo;). For example (taken from the official documentation):\nCOUNTER=20 until [ $COUNTER -lt 10 ]; do echo COUNTER $COUNTER let COUNTER-=1 done  Things to notice:\n The output should be similar to:\nCOUNTER 20 [...] COUNTER 10  Notice how the values printed were the ones when the condition was not true (zero)\n  There\u0026rsquo;s a let command that will get covered in the subsequent section\n  Case statement It\u0026rsquo;s a powerful statement that allows us to easily match input patterns. In other programming languages this is known also as \u0026lsquo;switch\u0026rsquo; statement\n Let\u0026rsquo;s create the script simplecase.bash, with the following content:\nread -p \u0026quot;Answer 'yes' or 'no': \u0026quot; ANS case \u0026quot;$ANS\u0026quot; in yes) echo \u0026quot;OK\u0026quot; ;; (no) echo \u0026quot;it's a 'no' then, thanks\u0026quot; ;; *) echo \u0026quot;you didn't specify anything :(\u0026quot; exit 1 ;; esac  Now run the script:\n$ bash simplecase.bash Answer 'yes' or 'no': no it's a 'no' then, thanks  Things to notice:\n The statement begins and ends with case and esac, respectively The values yes and no are actually shell pattern matches, so we could have specified y* and n* and the result would be the same If nothing is matched, then the shell pattern match (*) for zero or more characters will kick in and return error (1) The conditions to evaluate must be separated by double semicolon ;; After the parenthesis you can either put the statement inline or in a new line The leading parenthesis in (no) is optional. In fact, must people tend to not specify it  Continue matching patterns As you\u0026rsquo;ve noticed, once there\u0026rsquo;s a pattern match the case statement will run the respective block and then exit the statement. Sometimes though, we want to continue matching all the remaining patterns (in order). This is possible since bash 4.0+.\nLet\u0026rsquo;s create another script simplecase2.bash with the following content:\ninput=\u0026quot;this is a dummy text\u0026quot; case \u0026quot;$input\u0026quot; in *a*) echo \u0026quot;Character 'a' is present\u0026quot; ;;\u0026amp; *is*) echo \u0026quot;Word 'is' is present\u0026quot; ;\u0026amp; *text) echo \u0026quot;Var ends with word 'text'. Now we exit with error\u0026quot; exit 1 ;; esac  Now run the script:\n$ bash simplecase2.bash Character 'a' is present Word 'is' is present Var ends with word 'text'. Now we exit with error  Things to notice:\n The feature to continue matching patterns is activated when we specify either ;;\u0026amp; or ;\u0026amp; at the end of each pattern match  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/11.command-substitution/",
	"title": "Command substitution",
	"tags": [],
	"description": "",
	"content": " Subshell shorthands formally known as command substitutions allows us to use a shorthand and run command within a subshell. The idea is to run a command and operate with the result in stdout immediately. See the official documentation in here.\nBasically there are two types:\nusing backticks or backquotes echo `ls`  using dollar + parenthesis echo $(ls)  Even though they both accomplish the same, it\u0026rsquo;s preffered the second method since it allows commands to be nested (which is not possible by using backticks)\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/11.logic-and-arithmetic/",
	"title": "Logic and Arithmetic",
	"tags": [],
	"description": "",
	"content": " Logic and arithmetic operation can give our bash scripts more accuracy and robustness against different types of values\nArithmetic expressions In bash to declare an integer is simply done with:\n$ declare -i COUNTER=0  Since the variable COUNTER now is an integer, we can also do this:\n$ COUNTER+=1 $ echo $COUNTER 1  let expression The \u0026lsquo;let\u0026rsquo; expression in bash signals that the following expression will be arithmetic. By knowing this, we can re-write our previous counter like this:\n$ let counter=10 $ let counter+=1 $ echo $counter 11  Even though the expression let counter+=1 worked, sometimes is good to keep things separated by space to improve readability. To achieve this, we\u0026rsquo;d have to envelop the whole arithmetic expression in quotes:\n$ let \u0026quot;counter = $counter * 2\u0026quot; $ echo $counter 22  Double parenthesis Another way to accomplish a counter is to use double parenthesis:\n$ (( counter += 10 )) $ echo $counter 32  Dollar sign double parenthesis Yet another way to do a counter is to use $(( )). In this case the result of the operation will be returned immediately:\n$ echo $(( counter += 10 )) 42 $ echo $counter 42  You don\u0026rsquo;t need dollar signs to reference the variables inside the arithmetic expression\n if statement (with arithmetic expressions) Using arithmetic expressions an if statement looks like this:\nlet var=200 if (( var \u0026lt; 200 )) then echo \u0026quot;value too low\u0026quot; elif (( var \u0026gt; 200 )) then echo \u0026quot;value too high\u0026quot; else echo \u0026quot;value is right\u0026quot; fi  Things to notice:\n We are using the same arithmetic expression we saw earlier After if and elif we must include then, but this is not required for else  We can build expressions much more powerful than this though. Let\u0026rsquo;s create a script simpleif.bash with the following content:\nlet number while true; do read -p \u0026quot;Guess the number? \u0026quot; number if (( number \u0026lt; 200 )); then echo \u0026quot;too low, try again\u0026quot; elif (( number \u0026gt; 200 )); then echo \u0026quot;too high, try again\u0026quot; fi if (( number == 200 || CHEAT != 0 )); then echo \u0026quot;Yay, you guessed it\u0026quot; if (( CHEAT != 0 )); then echo \u0026quot;Actually, you're a cheater ^.^\u0026quot; exit 1 fi exit 0 fi done  Now run the script:\n$ CHEAT=1 bash simpleif.bash Guess the number? 200 Yay, you guessed it Actually, you're a cheater ^.^  Things to point out:\n This expression number == 200 || CHEAT != 0 is a logical OR, as provided in other programming languages.  if statement (with test expressions) if statement with single square brackets Has the form if [ expr ]\nThe whitespaces around the brackets are absolutely necessary\n There are many test expressions, which are listed in here\nFor example if we wanted to know if a file exists, we can do it with:\nfile=\u0026quot;testfile\u0026quot; touch $file if [ -e $file ]; then echo \u0026quot;the file exists\u0026quot; fi  Similarly, sometimes it\u0026rsquo;s useful to check the negation of the test expression. For example, if we were to test if a file does not exist, we can do it with:\nfile=\u0026quot;nonexistentfile\u0026quot; if [ ! -e $file ]; then echo \u0026quot;the file does not exist\u0026quot; fi  Another thing to point out is that there exist comparison operators in this notation, however they can be grouped into two categories:\nLexicographical comparison It means that the strings get compared in character by character basis. These are: ==, \u0026gt;, and \u0026lt;, for example:\nstr1=\u0026quot;something1\u0026quot; str2=\u0026quot;something2\u0026quot; if [ \u0026quot;$str1\u0026quot; \u0026gt; \u0026quot;$str2\u0026quot; ]; then echo \u0026quot;'$str1' is lexicographically greater than '$str2'\u0026quot; fi  That should give:\n'something1' is lexicographically greater than 'something2'  It\u0026rsquo;s always a good idea to envelop strings in double quotes, just in case they have spaces\n Numerical comparison These are homogeneous to the arithmetic comparison operators, but now are more a sort of legacy support for backwards compatibility. They include: -eq, -lt, -gt, -ge, -le.\nFor example:\nnum1=20 num2=34 if [ $num1 -le $num2 ]; then echo \u0026quot;'$num1' is less or equal than '$num2'\u0026quot; fi  Which should print:\n'20' is less or equal than '34'  For readability purposes, I do prefer to use the arithmetic notation when comparing arithmetic expressions, rather than using these operators.\nif statement with double square brackets Has the form if [[ expr ]]\nAgain, the whitespaces around the brackets are absolutely necessary\n This is a sort of more modern way of comparing in bash. Taken from the documentation:\n Contrary to [, [[ prevents word splitting of variable values. So, if VAR=\u0026ldquo;var with spaces\u0026rdquo;, you do not need to double quote \\$VAR in a test - eventhough using quotes remains a good habit. Also, [[ prevents pathname expansion, so literal strings with wildcards do not try to expand to filenames. Using [[, == and != interpret strings to the right as shell glob patterns to be matched against the value to the left, for instance: [[ \u0026ldquo;value\u0026rdquo; == val* ]]\n What that means is that using double brackets we can use powerful comparisons such as the following:\nfile1=something.txt if [[ \u0026quot;$file1\u0026quot; == *.txt ]]; then echo \u0026quot;The file specified has 'txt' extension\u0026quot; fi  Another powerful use case is when we want to compare against regular expressions. For example:\nstr=\u0026quot;the elephant in the room was not only real but just a toy.\u0026quot; if [[ \u0026quot;$str\u0026quot; =~ ^t.*not.*toy.$ ]]; then echo \u0026quot;The regular expression pattern has matched\u0026quot; fi  We do not need to use double quotes when using double brackets, however I think it\u0026rsquo;s a good practice\n "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/12.functions/",
	"title": "Functions",
	"tags": [],
	"description": "",
	"content": " Functions provide with the ability of reuse code and more importantly to follow the DRY principle: Don\u0026rsquo;t Repeat Yourself.\nFunction definition A function can be defined as follows:\nfunction myfunc () { echo \u0026quot;Hey, there!\u0026quot; }  Then to invoke it as if it were a bash command or program, just run it:\n$ myfunc Hey, there!  There are alternative syntaxes to declare functions. All of the following are accomplishing the same:\nNo optional parenthesis at the end function myfunc { echo \u0026quot;Hey, there!\u0026quot; }  No word \u0026lsquo;function\u0026rsquo; but implicit with parenthesis myfunc() { echo \u0026quot;Hey, there!\u0026quot; }  Grouping blocks of a function Even though normally we\u0026rsquo;d want to run a function as part of the main shell. Sometimes it\u0026rsquo;s useful not to do so. Let\u0026rsquo;s have a look at the following examples.\nRun function in a subshell function mysubshellfunc() ( echo \u0026quot;Hey, I'm running from within a subshelll\u0026quot; )  The implication of this is that the variables that can be accessed will be limited.\nIt\u0026rsquo;s recommended to previously export variables when invoking a subshell\n Run only arithmetic expressions function myarithmeticfunction() (( C+=1 ))  Function parameters For the duration of the function execution, the parameters beginning with dollar (e.g. $1, $2, \u0026hellip; ) are re-defined to store the values passed when invoking the function. For example\nfunction myfuncwithparams(){ echo \u0026quot;You've specified $# params: $@. Let's print some of them: '$1', '$2'\u0026quot; } myfuncwithparams \u0026quot;one\u0026quot; myfuncwithparams \u0026quot;one\u0026quot; 2 \u0026quot;three and four\u0026quot;  Of course, the output should be:\nYou've specified 1 params: one. Let's print some of them: 'one', '' You've specified 3 params: one 2 three and four. Let's print some of them : 'one', '2'  Also using some string substitutions we could make this a bit more smart:\nfunction myfuncwithparams(){ msg=\u0026quot;You've specified $# params: $@.\u0026quot; if (( $# \u0026lt; 1 )); then echo \u0026quot;No params were specified :(\u0026quot; elif (( $# == 1 )); then echo \u0026quot;${msg/params/param} Let's print it: '$1'\u0026quot; else echo \u0026quot;${msg} Let's print some of them: '$1'. '$2'\u0026quot; fi } myfuncwithparams myfuncwithparams \u0026quot;one\u0026quot; myfuncwithparams \u0026quot;one\u0026quot; 2 \u0026quot;three and four\u0026quot;  Of course, the output should be:\nNo params were specified :( You've specified 1 param: one. Let's print it: 'one' You've specified 3 params: one 2 three and four. Let's print some of them : 'one'. '2'  It\u0026rsquo;s quite handy to do string substitutions like the oe above\n "
},
{
	"uri": "https://kajahno.me/bash-notes/en/",
	"title": "Bash notes",
	"tags": [],
	"description": "",
	"content": " Bash notes This will be a set of notes related to GNU bash. By no means this will be a complete showcase of all the features bash has to offer, however I will be updating this documentation from time to time to make it as more accurate as possible.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it. Similarly if you want to indicate some changes, feel free to open an issue about it.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kajahno.me/bash-notes/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Site generator  Hugo Hugo Theme Learn  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]