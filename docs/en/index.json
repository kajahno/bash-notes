[
{
	"uri": "https://kajahno.me/bash-notes/en/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Basics Covers the fundamental concepts used when working within bash (applicable to other shells)\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/1.introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " The GNU Bourne-Again SHell is a very popular shell that combines functionalities for both programming and interactive use.\nOther shells  C shell - csh KornShell - ksh Bourne shell - sh Z shell - zsh with Oh-my-zsh Debian Almquist shell - dash  What is a \u0026lsquo;shell\u0026rsquo; then? It\u0026rsquo;s a program that receives input from the keyboard and forwards them to the operating system. It was the first kind of user interface used.\nWhat is a \u0026lsquo;terminal [emulator]\u0026lsquo;? Nowadays, most operating systems provide a Graphical User Interface (GUI). A terminal emulator is a program that lets you interact with a shell. Examples include: gnome-terminal, terminator.\nStarting bash Assumming you\u0026rsquo;re in an operating system that has a GUI, just open your favorite terminal emulator and type:\n$ bash  Printing the version of bash:\n$ bash --version GNU bash, version 4.3.48(1)-release (x86_64-pc-linux-gnu) Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software; you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.  Modes of execution In bash you can either type commands and run them immediately (interactive), or place them in a file and then run as a batch of commands (also known as a bash script)\nInteractive Print the working directory:\n$ pwd /home/vagrant  list the files and directories in current directory:\n$ ls  Non-interactive (bash script) Create a file (named myfile) and place the following content in it:\npwd ls  Run that file using bash\n$ bash myfile /home/vagrant myfile  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/2.io-redirection/",
	"title": "IO Redirection",
	"tags": [],
	"description": "",
	"content": " graph LR; inp[stdin] -- p(program) p -- stdout[stdout] p -- stderr[stderr] classDef middle stroke:#333,stroke-width:4px; classDef edge fill:#fff,stroke:#333,stroke-width:0px; class p middle; class inp edge; class stdout edge; class stderr edge;  By convention any shell opens three file descriptors when a program is run:\n Standard input (stdin): feeds the program with data Standard output (stdout): normally prints messages in the terminal Standard error (stderr): normally prints error messages in the terminal (when things fail)  These three file descriptors are referred as non-negative integers (defined by the POSIX standard):\n stdin: 0 stdout: 1 (this is the default) stderr: 2  A very powerful feature of bash (and other shells) is input and output redirection. If no redirection is specified, by default all three file descriptors are connected to the terminal (so the information will be displayed)\nRun program with no redirection $ ls -l total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Redirect standard output $ ls -l 1\u0026gt; output  As you see, nothing was printed. The output has been redirected to the file output. If we print the content of this file we\u0026rsquo;ll see that indeed the output is there:\n$ cat output total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Since the file descriptor 1 is the default file descriptor in bash, we can simple run the following and achieve the same result:\n$ ls -l \u0026gt;output $ cat output total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Redirect standard error To redirect the standard error, we first need to create an error:\n$ ls --bad-usage ls: unrecognized option '--bad-usage' Try 'ls --help' for more information.  As you see, that option --bad-usage doesn\u0026rsquo;t really form part of the command ls. However, because by default everything is redirected to the terminal, we also see the stderr output.\nLet\u0026rsquo;s redirect that to a new file:\n$ ls --bad-usage 2\u0026gt; error_output  Notice how there was nothing printed to the terminal, however by inspecting the content of the file we can confirm that indeed we have successfully redirected stderr:\n$ cat error_output ls: unrecognized option '--bad-usage' Try 'ls --help' for more information.  Redirect stdout and stderr We can combine both output redirections in a single line:\n$ ls -l output non-existing-file \u0026gt;newoutput 2\u0026gt;newerr  Nothing will get printed in the terminal. However by inspecting the content of those two new files newoutput and newerr we can confirm that the redirection took place:\n$ cat newoutput -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output $ cat newerr ls: cannot access 'non-existing-file': No such file or directory  Combine stdout and stderr Sometimes is pretty convenient to redirect both stdout and stderr a single file. This can be achieved with:\n$ ls -l output non-existing-file \u0026gt;combined-output 2\u0026gt;\u0026amp;1  In this case we are explicitly telling bash to combine (or pipe) stderr into stdout. Inspecting the new file:\n$ cat combined-output ls: cannot access 'non-existing-file': No such file or directory -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output  A shorthand for this syntax is: ls -l output non-existing-file \u0026amp;\u0026gt;combined-output\n Redirect stdin For this we need to make sure the program we use supports stdin.\nThe program wc prints words, lines, and the byte count of the specified input. For example:\n$ wc combined-output 2 18 118 combined-output  wc is using the input file specified as argument. Running wc with no arguments, and typing manually:\n$ wc this is a test second line [CRTL+d] 2 6 27  Will produce the output base on what was specified in stdin. We use CRTL+d to indicate the end of input. In this occasion, of course, wc is reading directly from stdin.\nNow if we were to redirect stdin, and specify a file as input instead of manually typing the content, we can by running:\n$ wc \u0026lt;combined-output 2 18 118  Redirect stdin with a heredoc When redirecting stdin we also have a way to explicitly specify the input, with a custom delimiter (not the interactive CTRL-d)\nThis can be achieved with the following:\n$ wc \u0026lt;\u0026lt;delimiter \u0026gt; this is a test \u0026gt; with a custom delimiter \u0026gt; delimiter 2 8 39  In this case the delimiter will only act as such if it\u0026rsquo;s the only word in a line of input. This way of redirecting is called here document or heredoc.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/reference/",
	"title": "Command reference",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Command reference Covers a list of commands and what they do\n io-redirection   "
},
{
	"uri": "https://kajahno.me/bash-notes/en/reference/io-redirection/",
	"title": "io-redirection",
	"tags": [],
	"description": "",
	"content": "Commands related to input and output\n   Command Description     PROGRAM \u0026gt;stdout redirect standard output of program to file stdout   PROGRAM 2\u0026gt;stderr redirect standard error output of program to file stderr   PROGRAM \u0026gt;combined 2\u0026gt;\u0026amp;1 redirect stderr and stdout outputs of program to file combined   PROGRAM \u0026amp;\u0026gt;combined redirect stderr and stdout outputs of program to file combined   PROGRAM \u0026lt; combined reads file combined and sends it as input to the program    "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/3.shell-pipelines/",
	"title": "Shell Pipelines",
	"tags": [],
	"description": "",
	"content": " graph LR; stdout1 -- PIPE -- inp2 subgraph program one inp1[stdin] -- p1(program) p1 -- stdout1[stdout] p1 -- stderr1[stderr] stderr1 -. optional .- stdout1 end subgraph program two inp2[stdin] -- p2(program) p2 -- stdout2[stdout] p2 -- stderr2[stderr] end classDef middle stroke:#333,stroke-width:4px; classDef edge fill:#ffffde,stroke:#333,stroke-width:0px; class p middle; class inp1 edge; class inp2 edge; class stdout1 edge; class stderr1 edge; class stdout2 edge; class stderr2 edge;  Some shells such as bash provide the ability of chaining program commands together. The way it works is that the standard output of one program as input to another program, all chained together by using the pipe (|) character.\nPrint content of a file and calculate word count This can be done with the following command:\n$ cat ~/.profile | wc 20 99 655  As we see, the output of the file ~/.profile has been redirected as input to the program wc\nList files redirecting stderr and calculate word count $ ls combined-output non-existent 2\u0026gt;\u0026amp;1 | wc -l 2  Regardless of both files existing or not, our output will show the same count since we have redirected stderr to stdout.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/4.job-management/",
	"title": "Job Management",
	"tags": [],
	"description": "",
	"content": " When running programs in bash, it\u0026rsquo;s possible to do it in a \u0026lsquo;detached\u0026rsquo; mode. That is, sending the job to the background and continuing using the terminal\nIn order to prepare for this, let\u0026rsquo;s create the plain file long-time with the following content in it:\necho 'process started' sleep 60 #time in seconds echo 'process ended'  You can run this file by doing:\n$ bash long-time  The downside is that it will take around 60 seconds, time in which the terminal will be busy and cannot be used.\nSend jobs to the background Just append an ampersand to the end of the command:\n$ bash long-time \u0026amp; [1] 1718  The good thing is that now we can keep using the terminal since the job is executing in the background. This can be confirmed by running:\n$ jobs [1]+ Running bash long-time \u0026amp;  Something you\u0026rsquo;ll notice is that even though the program is running in the background, the output is being redirected to the terminal. Of course, we can redirect it as well.\nSimilarly we can end or kill jobs that are in the background, as follows:\n$ kill %1 $ [1]+ Terminated bash long-time  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/5.bash-options/",
	"title": "Bash options",
	"tags": [],
	"description": "",
	"content": " Running a bash script has some interesting options that are worth mentioning. Let\u0026rsquo;s explore them here.\nIn order to prepare for this, let\u0026rsquo;s create the plain file script1 with the following content in it:\necho 'process started' ls non-existing sleep 10 #time in seconds touch somefile ls -l somefile echo 'process ended'  Check for syntax validity $ bash -n script1  When nothing is printed, the syntax is fine\nOutput commands as they\u0026rsquo;re being read Using verbose flag:\n$ bash -v script1 echo 'process started' process started ls non-existing ls: cannot access 'non-existing': No such file or directory sleep 10 #time in seconds touch somefile ls -l somefile -rw-rw-r-- 1 vagrant vagrant 0 Nov 24 23:06 somefile echo 'process ended' process ended  Notice how the comment is also being printed\n Using the -x flag:\n$ bash -x script1 + echo 'process started' process started + ls non-existing ls: cannot access 'non-existing': No such file or directory + sleep 10 + touch somefile + ls -l somefile -rw-rw-r-- 1 vagrant vagrant 0 Nov 24 23:08 somefile + echo 'process ended' process ended  It shows every line being executed. Also arguably more readable than a plain -v. Notice how the comment is being ignored\n "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/6.decision-making/",
	"title": "Decision Making",
	"tags": [],
	"description": "",
	"content": " Making decisions help our scripts to have better flow control and add additionally robustness and avoid repetition.\nInline syntax This syntax is composed of two operators: and (\u0026amp;\u0026amp;) and or ||\nAnd (\u0026amp;\u0026amp;) case Run a command and run another one if the former was successful:\n$ ls \u0026amp;\u0026amp; echo 'yay, command was successful' combined-output long-time newerr output somefile error_output myfile newoutput script1  As shown before, of course we can redirect stdout of the former command:\n$ ls 1\u0026gt;/dev/null \u0026amp;\u0026amp; echo 'yay, command was successful' yay, command was successful  redirecting to /dev/null basically means that we\u0026rsquo;re discarding the output\n Or (||) case Run a command and run another one if the former failed:\n$ ls /nonexistent || echo 'partition /nonexistent does not exist' ls: cannot access '/nonexistent': No such file or directory partition /nonexistent does not exist  As shown before, of course we can redirect stderr of the former command:\n$ ls /nonexistent 2\u0026gt;/dev/null || echo 'partition /nonexistent does not exist' partition /nonexistent does not exist  Combining \u0026amp;\u0026amp; and || Sometimes is useful to run a command when another one is successful, and another one when it fails.\nFor example consider the following command:\n$ cd /tmp \u0026amp;\u0026amp; echo 'command succeeded, removing old files' || echo 'command failed, aborting' command succedded  In case it succeeds we could perform some housekeeping operation and remove old logs. On the other hand if the command failed we would most likely want to abort and exit\nOf course at this point we have only echoes so nothing is actually done. If we were to perform this sort of housekeeping using these operators it would be something similar to:\n Case of success\n$ cd /tmp \u0026amp;\u0026amp; { echo 'command succeeded, removing old files' \u0026amp;\u0026amp; find -type f -mtime +2 -delete \u0026amp;\u0026amp; echo 'files removed';} || { echo 'command failed, aborting';} command succeeded, removing old files files removed  Case of failure\n$ cd /tmp2 \u0026amp;\u0026amp; { echo 'command succeeded, removing old files' \u0026amp;\u0026amp; find -type f -mtime +2 -delete \u0026amp;\u0026amp; echo 'files removed';} || echo 'command failed, aborting' -bash: cd: /tmp2: No such file or directory command failed, aborting   As you can see to perform this operation, things start to get fiddly. In order to group decisions we would need to envelop them in curly braces, and to make things worse, the closing curly brace must have a semicolon just before. Please do not use this as a reference to write long bash scripts. Your future self will appreciate when you have to change and old script without all these conditions in it.\n The command find -type f -mtime +2 -delete means: find files only with more than 2 days older and delete them\n Extended syntax Using last example as a reference, let\u0026rsquo;s refactor using an if statement:\nif cd /tmp then echo 'command succeeded, removing old files' if find -type f -mtime +2 -delete; then echo 'files removed' else echo 'files failed to remove' fi else echo 'command failed, aborting' fi command succeeded, removing old files files removed  A couple of things to notice here:\n the first line of the if statement can have the then next, provided that it\u0026rsquo;s specified as a separate command (using semicolon) syntax is super clear and easier to maintain there is a bit of repetition in the case of failure After the then we don\u0026rsquo;t really need a newline or separator, so this would work just fine: if CONDITION; then echo 'something; fi  Using the syntax if TEST; then as an example. What goes in between if and then is called a \u0026lsquo;test command\u0026rsquo;. The amount of test commands in Bash could be intimidating at first, but once you get the hang of it, they make a lot of sense and are easy to remember. A list of those can be found in here.\nAs an extended example here\u0026rsquo;s how to ask for another condition just before the default else:\nif cd /tmp2 then echo 'command succeeded, removing old files' if find -type f -mtime +2 -delete; then echo 'files removed' else echo 'files failed to remove' fi elif cd /tmp then echo 'second command succeeded' else echo 'command failed, aborting' fi -bash: cd: /tmp2: No such file or directory second command succeeded  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/7.success-or-failure/",
	"title": "Success of Failure",
	"tags": [],
	"description": "",
	"content": " In previous examples we\u0026rsquo;ve referred to \u0026lsquo;success\u0026rsquo; or \u0026lsquo;failure\u0026rsquo; when running commands within bash. This is closely related to the return codes of the programs we call in our commands. To find what was the return code of a particular program, just access the magic variable $? after invoking the program.\nFor this section create a file named return-codes and put the following content it in:\nif [ $1 == 'success' ] then echo 'success' exit 0 else echo 'failure' \u0026gt;\u0026amp;2 exit 1 fi  The $1 is making reference to the first argument passed to the bash script at invocation\n What is \u0026lsquo;success\u0026rsquo; then? It\u0026rsquo;s when a program returns a return code of 0.\nFor example:\n$ echo hi there hi there $ echo $? 0  Now using our little script:\n$ bash return-codes success success $ echo $? 0  And what about \u0026lsquo;failure\u0026rsquo;? It\u0026rsquo;s when a program returns a non-zero return code.\nFor example:\n$ ls non-existent ls: cannot access 'non-existent': No such file or directory $ echo $? 2  And using our script:\n$ bash return-codes fail fail $ echo $? 1  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/8.variables/",
	"title": "Variables",
	"tags": [],
	"description": "",
	"content": " In bash and many other programming languages, a variable is a container where we can store values and reference/modify them later on.\nVariable names Must begin with alphanumeric character or underscore, and end with one or more alphanumeric or underscore characters.\nBy convention bash variables tend to be in uppercase, however that depends on the style of programming. Personally I tend to name variables in upper case when they are in a global scope (at the beginning of a script) , and in lowercase when in local scope (inside a function or statement).\nDeclaring a variable VAR1=\u0026quot;some value\u0026quot; var1=\u0026quot;some other value\u0026quot; var4='some other value with singlequotes' var_with_underscores=\u0026quot;some value with underscores: ___\u0026quot; var_with_no_spaces=this_val_with-no-spaces  In the above it\u0026rsquo;s good to point out:\n Variable names are case sensitive (just like file names in Linux) There is no space whatsoever when assigning a value to a variable (e.g. wrong declarations include -\u0026gt; var= \u0026quot;some val\u0026quot;, var = \u0026quot;some val\u0026quot;, var =\u0026quot;some val\u0026quot;) Variables must not start with numbers Variables that have spaces as value will need quotes around them (either single or double) Variables that do not have spaces as values do not need quotes  Accessing a variable Just specify the name of the variable, preceded by dollar sign ($):\n$ echo $VAR1 some value $ echo $var1 some other value $ echo $var4 some other value with singlequotes $ echo $var_with_underscores some value with underscores: ___ $ echo $var_with_no_spaces this_val_with-no-spaces  Now this approach is normally fine when printing a single variable, but not so useful when concatenating:\n two variables together -\u0026gt; $VAR1$var1 a variable with a string -\u0026gt; \\$VAR1somestring  For these cases the best practice is to envelop the name of the variable within curly braces:\n$ echo ${VAR1}${var1} some valuesome other value $ echo ${VAR1}s, because life is boring with a single value some values, because life is boring with a single value  Now in that second example, since the value we\u0026rsquo;re printing contains spaces (and it\u0026rsquo;s perfectly supported by echo), it\u0026rsquo;s a good practice to envelop everything in double quotes:\n$ echo \u0026quot;${VAR1}s, because life is boring with a single value\u0026quot; some values, because life is boring with a single value  Note that if single quotes were used instead, the value of the variable would not get substituted as almost always wanted:\n$ echo '${VAR1}s, because life is boring with a single value' ${VAR1}s, because life is boring with a single value  Variable as commands Let\u0026rsquo;s put a command as the content of a variable:\ncustom_ls=\u0026quot;ls -lrt\u0026quot;  Then if you just expand the value of that variable in the shell:\n$ $custom_ls total 32 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output [...]  Propagate variable across subshells A subshell is when bash is invoked from within bash (either explicitly or implicitly), for example: $ bash will return a subshell\n All the variables that we declare, by default will not get propagated to child subshells. This is particularly annoying if we call bash scripts that are expecting some variables to be already defined.\nExample of variable not getting propagated to a subshell:\n$ localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ bash $ echo $localvar $ exit $ echo $localvar 42 is a great number  In order to make a variable get propagated to subshells, we must first export it:\n$ localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ export localvar $ bash $ echo $localvar 42 is a great number  Notice how the export command does not have a dollar sign\n We can also export and define the variable in one go:\n$ export localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ bash $ echo $localvar 42 is a great number  Another way to export variables is by using the command declare with the -x flag:\n$ declare -x localvar=\u0026quot;42 is a great number\u0026quot; $ echo $localvar 42 is a great number $ bash $ echo $localvar 42 is a great number  Going back to the example where we want to pass a specific variable for the duration of the script, we can pass an ephemeral variable like this:\n Create a file script2 with the following content:\necho \u0026quot;Value passed is: $ephemeral_var\u0026quot;  Give the file execution permissions\n$ chmod +x script2  Run script without specifying the variable\n$ ./script2 Value passed is:  Specify the variable only for the duration of that script\n$ ephemeral_var=\u0026quot;42, of course\u0026quot; ./script2 Value passed is: 42, of course   String substitution Assuming we have the following variable:\n$ myvar=\u0026quot;todo muy muy bien\u0026quot;   Removing trailing strings: if we were to remove the word bien from right to left, we can simply do:\n$ echo \u0026quot;${myvar%bien}\u0026quot; todo muy muy  Removing trailing pattern (shell matching file patterns):\n single character (? matches any one character): remove last character\n$ echo \u0026quot;${myvar%?}\u0026quot; todo muy muy bie  many characters (* matches zero or more characters): remove everything after the m\n$ echo \u0026quot;${myvar%m*}\u0026quot; todo muy  many characters (* matches zero or more characters): remove everything after the m, make sure it\u0026rsquo;s largest possible match of character m\n$ echo \u0026quot;${myvar%%m*}\u0026quot; todo  rename filename extension: from .jpg to .png\n$ imagename=photo1.jpg $ echo \u0026quot;${imagename%.jpg}.png\u0026quot; photo1.png  extract path from absolute path to filename /home/vagrant/mydir/myfile.txt\n$ filename=/home/vagrant/mydir/myfile.txt $ echo \u0026quot;path is '${filename%/*}'\u0026quot; path is '/home/vagrant/mydir'  Note: the bash command dirname does exactly this\n  Removing leading pattern (shell matching file patterns):\n single character (? matches any one character): remove first character\n$ echo \u0026quot;${myvar#?}\u0026quot; odo muy muy bien  many characters (* matches zero or more characters): remove everything before the m\n$ echo \u0026quot;${myvar#*m}\u0026quot; uy muy bien  many characters (* matches zero or more characters): remove everything before the m, make sure it\u0026rsquo;s largest possible match of character m\n$ echo \u0026quot;${myvar##*m}\u0026quot; uy bien  parse username and host parts from string john@10.0.0.20\n$ conn_str=\u0026quot;john@10.0.0.20\u0026quot; $ host=\u0026quot;${conn_str%*@}\u0026quot; $ echo $host 10.0.0.20 $ username=\u0026quot;${conn_str%@*}\u0026quot; $ echo $username john  extract filename from absolute path to filename /home/vagrant/mydir/myfile.txt\n$ filename=/home/vagrant/mydir/myfile.txt $ echo \u0026quot;filename is '${filename##*/}'\u0026quot; filename is 'myfile.txt'  Note: the bash command basename does exactly this.\n  Replacing pattern from middle of string:\n Replace bien for bueno in string muy muy bien\n$ echo \u0026quot;${myvar/bien/bueno}\u0026quot; todo muy muy bueno  Note: there\u0026rsquo;s a very powerful bash program called sed that does this and much more\n   Special variables  Return value of command ran: stored in $? Current prompt: $PS1 Current path (where all the programs that can be run are located): $PATH Home directory: $HOME  More information about variables is in here\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/9.bash-scripts/",
	"title": "Bash scripts",
	"tags": [],
	"description": "",
	"content": " Bash scripts enable us to reutilize a set of commands and provide robustness on our daily actions. Knowing this is a must for doing any kind of automation using bash.\nReading parameters Consider the following script:\n create a file params1.bash and place the content in:\necho $0 echo $1 echo $2  change the permissions and run it:\n$ chmod +x params1.bash $ ./params1.bash one ./script1.bash one   As you can see the parameter $0 corresponds to the name of the script, and any other command line parameter is enumerated from $1 onwards.\nDifference between command line parameter, argument, and option thanks to this fellow\n Accessing all parameters  create a file params2.bash and place the following content inside:\necho $# echo $* echo $@  change permissions and run it with some params:\n$ chmod +x params2.bash $ ./params2.bash one two three 3 one two three one two three   As you see:\n $#: counts how many arguments were passed $*: provides all arguments $@: provides all arguments  Now, even though in both $* and $@ we appear to have the same result, there\u0026rsquo;s a subtle difference. Let\u0026rsquo;s modify our script to call another script as see what\u0026rsquo;s going on:\n Create another script params3.bash with the following content:\necho \u0026quot;number of args: $#\u0026quot;  Give it execution permissions\n$ chmod +x params3.bash  Now edit the params2.bash with the following content:\necho $# ./params3.bash $* ./params3.bash $@ ./params3.bash \u0026quot;$*\u0026quot; ./params3.bash \u0026quot;$@\u0026quot;  Run it with a particular set of params and observe the result:\n$ ./params2.bash one two three \u0026quot;and four\u0026quot; 4 number of args: 5 number of args: 5 number of args: 1 number of args: 4   Sure enough those results might not be what you expected. Let\u0026rsquo;s go case by case:\n ./params3.bash $*: sent the following args -\u0026gt; one two three and four ./params3.bash $@: sent the following args -\u0026gt; one two three and four ./params3.bash \u0026quot;$*\u0026quot;: sent the following args -\u0026gt; \u0026ldquo;one two three and four\u0026rdquo; ./params3.bash \u0026quot;$@\u0026quot;: sent the following args -\u0026gt; \u0026lsquo;one two three \u0026ldquo;and four\u0026rdquo;\u0026rsquo;  Normally the intended thing we want to do, which is to forward all arguments, is accomplished in the last case. We are going to see more of this when covering arrays.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/",
	"title": "Bash notes",
	"tags": [],
	"description": "",
	"content": " Bash notes This will be a set of notes related to GNU bash. By no means this will be a complete showcase of all the features bash has to offer, however I will be updating this documentation from time to time to make it as more accurate as possible.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it. Similarly if you want to indicate some changes, feel free to open an issue about it.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kajahno.me/bash-notes/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Site generator  Hugo Hugo Theme Learn  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]