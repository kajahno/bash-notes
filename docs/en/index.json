[
{
	"uri": "https://kajahno.me/bash-notes/en/basics/",
	"title": "Basics",
	"tags": [],
	"description": "",
	"content": " Chapter 1 Basics Covers the fundamental concepts used when working within bash (applicable to other shells)\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " The GNU Bourne-Again SHell is a very popular shell that combines functionalities for both programming and interactive use.\nOther shells  C shell - csh KornShell - ksh Bourne shell - sh Z shell - zsh with Oh-my-zsh Debian Almquist shell - dash  What is a \u0026lsquo;shell\u0026rsquo; then? It\u0026rsquo;s a program that receives input from the keyboard and forwards them to the operating system. It was the first kind of user interface used.\nWhat is a \u0026lsquo;terminal [emulator]\u0026lsquo;? Nowadays, most operating systems provide a Graphical User Interface (GUI). A terminal emulator is a program that lets you interact with a shell. Examples include: gnome-terminal, terminator.\nStarting bash Assumming you\u0026rsquo;re in an operating system that has a GUI, just open your favorite terminal emulator and type:\n$ bash  Printing the version of bash:\n$ bash --version GNU bash, version 4.3.48(1)-release (x86_64-pc-linux-gnu) Copyright (C) 2013 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u0026lt;http://gnu.org/licenses/gpl.html\u0026gt; This is free software; you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law.  Modes of execution In bash you can either type commands and run them immediately (interactive), or place them in a file and then run as a batch of commands (also known as a bash script)\nInteractive Print the working directory:\n$ pwd /home/vagrant  list the files and directories in current directory:\n$ ls  Non-interactive (bash script) Create a file (named myfile) and place the following content in it:\npwd ls  Run that file using bash\n$ bash myfile /home/vagrant myfile  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/io-redirection/",
	"title": "IO Redirection",
	"tags": [],
	"description": "",
	"content": " graph LR; inp[stdin] -- p(program) p -- stdout[stdout] p -- stderr[stderr] classDef middle stroke:#333,stroke-width:4px; classDef edge fill:#fff,stroke:#333,stroke-width:0px; class p middle; class inp edge; class stdout edge; class stderr edge;  By convention any shell opens three file descriptors when a program is run:\n Standard input (stdin): feeds the program with data Standard output (stdout): normally prints messages in the terminal Standard error (stderr): normally prints error messages in the terminal (when things fail)  These three file descriptors are referred as non-negative integers (defined by the POSIX standard):\n stdin: 0 stdout: 1 (this is the default) stderr: 2  A very powerful feature of bash (and other shells) is input and output redirection. If no redirection is specified, by default all three file descriptors are connected to the terminal (so the information will be displayed)\nRun program with no redirection $ ls -l total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Redirect standard output $ ls -l 1\u0026gt; output  As you see, nothing was printed. The output has been redirected to the file output. If we print the content of this file we\u0026rsquo;ll see that indeed the output is there:\n$ cat output total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Since the file descriptor 1 is the default file descriptor in bash, we can simple run the following and achieve the same result:\n$ ls -l \u0026gt;output $ cat output total 4 -rw-rw-r-- 1 vagrant vagrant 7 Nov 24 13:20 myfile  Redirect standard error To redirect the standard error, we first need to create an error:\n$ ls --bad-usage ls: unrecognized option '--bad-usage' Try 'ls --help' for more information.  As you see, that option --bad-usage doesn\u0026rsquo;t really form part of the command ls. However, because by default everything is redirected to the terminal, we also see the stderr output.\nLet\u0026rsquo;s redirect that to a new file:\n$ ls --bad-usage 2\u0026gt; error_output  Notice how there was nothing printed to the terminal, however by inspecting the content of the file we can confirm that indeed we have successfully redirected stderr:\n$ cat error_output ls: unrecognized option '--bad-usage' Try 'ls --help' for more information.  Redirect stdout and stderr We can combine both output redirections in a single line:\n$ ls -l output non-existing-file \u0026gt;newoutput 2\u0026gt;newerr  Nothing will get printed in the terminal. However by inspecting the content of those two new files newoutput and newerr we can confirm that the redirection took place:\n$ cat newoutput -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output $ cat newerr ls: cannot access 'non-existing-file': No such file or directory  Combine stdout and stderr Sometimes is pretty convenient to redirect both stdout and stderr a single file. This can be achieved with:\n$ ls -l output non-existing-file \u0026gt;combined-output 2\u0026gt;\u0026amp;1  In this case we are explicitly telling bash to combine (or pipe) stderr into stdout. Inspecting the new file:\n$ cat combined-output ls: cannot access 'non-existing-file': No such file or directory -rw-rw-r-- 1 vagrant vagrant 110 Nov 24 14:14 output  A shorthand for this syntax is: ls -l output non-existing-file \u0026amp;\u0026gt;combined-output\n Redirect stdin For this we need to make sure the program we use supports stdin.\nThe program wc prints words, lines, and the byte count of the specified input. For example:\n$ wc combined-output 2 18 118 combined-output  wc is using the input file specified as argument. Running wc with no arguments, and typing manually:\n$ wc this is a test second line [CRTL+d] 2 6 27  Will produce the output base on what was specified in stdin. We use CRTL+d to indicate the end of input. In this occasion, of course, wc is reading directly from stdin.\nNow if we were to redirect stdin, and specify a file as input instead of manually typing the content, we can by running:\n$ wc \u0026lt;combined-output 2 18 118  Redirect stdin with a heredoc When redirecting stdin we also have a way to explicitly specify the input, with a custom delimiter (not the interactive CTRL-d)\nThis can be achieved with the following:\n$ wc \u0026lt;\u0026lt;delimiter \u0026gt; this is a test \u0026gt; with a custom delimiter \u0026gt; delimiter 2 8 39  In this case the delimiter will only act as such if it\u0026rsquo;s the only word in a line of input. This way of redirecting is called here document or heredoc.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/reference/",
	"title": "Command reference",
	"tags": [],
	"description": "",
	"content": " Chapter 2 Command reference Covers a list of commands and what they do\n io-redirection   "
},
{
	"uri": "https://kajahno.me/bash-notes/en/reference/io-redirection/",
	"title": "io-redirection",
	"tags": [],
	"description": "",
	"content": "Commands related to input and output\n   Command Description     PROGRAM \u0026gt;stdout redirect standard output of program to file stdout   PROGRAM 2\u0026gt;stderr redirect standard error output of program to file stderr   PROGRAM \u0026gt;combined 2\u0026gt;\u0026amp;1 redirect stderr and stdout outputs of program to file combined   PROGRAM \u0026amp;\u0026gt;combined redirect stderr and stdout outputs of program to file combined   PROGRAM \u0026lt; combined reads file combined and sends it as input to the program    "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/shell-pipelines/",
	"title": "Shell Pipelines",
	"tags": [],
	"description": "",
	"content": " graph LR; stdout1 -- PIPE -- inp2 subgraph program one inp1[stdin] -- p1(program) p1 -- stdout1[stdout] p1 -- stderr1[stderr] stderr1 -. optional .- stdout1 end subgraph program two inp2[stdin] -- p2(program) p2 -- stdout2[stdout] p2 -- stderr2[stderr] end classDef middle stroke:#333,stroke-width:4px; classDef edge fill:#ffffde,stroke:#333,stroke-width:0px; class p middle; class inp1 edge; class inp2 edge; class stdout1 edge; class stderr1 edge; class stdout2 edge; class stderr2 edge;  Some shells such as bash provide the ability of chaining program commands together. The way it works is that the standard output of one program as input to another program, all chained together by using the pipe (|) character.\nPrint content of a file and calculate word count This can be done with the following command:\n$ cat ~/.profile | wc 20 99 655  As we see, the output of the file ~/.profile has been redirected as input to the program wc\nList files redirecting stderr and calculate word count $ ls combined-output non-existent 2\u0026gt;\u0026amp;1 | wc -l 2  Regardless of both files existing or not, our output will show the same count since we have redirected stderr to stdout.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/job-management/",
	"title": "Job Management",
	"tags": [],
	"description": "",
	"content": " When running programs in bash, it\u0026rsquo;s possible to do it in a \u0026lsquo;detached\u0026rsquo; mode. That is, sending the job to the background and continuing using the terminal\nIn order to prepare for this, let\u0026rsquo;s create the plain file long-time with the following content in it:\necho 'process started' sleep 60 #time in seconds echo 'process ended'  You can run this file by doing:\n$ bash long-time  The downside is that it will take around 60 seconds, time in which the terminal will be busy and cannot be used.\nSend jobs to the background Just append an ampersand to the end of the command:\n$ bash long-time \u0026amp; [1] 1718  The good thing is that now we can keep using the terminal since the job is executing in the background. This can be confirmed by running:\n$ jobs [1]+ Running bash long-time \u0026amp;  Something you\u0026rsquo;ll notice is that even though the program is running in the background, the output is being redirected to the terminal. Of course, we can redirect it as well.\nSimilarly we can end or kill jobs that are in the background, as follows:\n$ kill %1 $ [1]+ Terminated bash long-time  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/bash-options/",
	"title": "Bash options",
	"tags": [],
	"description": "",
	"content": " Running a bash script has some interesting options that are worth mentioning. Let\u0026rsquo;s explore them here.\nIn order to prepare for this, let\u0026rsquo;s create the plain file script1 with the following content in it:\necho 'process started' ls non-existing sleep 10 #time in seconds touch somefile ls -l somefile echo 'process ended'  Check for syntax validity $ bash -n script1  When nothing is printed, the syntax is fine\nOutput commands as they\u0026rsquo;re being read Using verbose flag:\n$ bash -v script1 echo 'process started' process started ls non-existing ls: cannot access 'non-existing': No such file or directory sleep 10 #time in seconds touch somefile ls -l somefile -rw-rw-r-- 1 vagrant vagrant 0 Nov 24 23:06 somefile echo 'process ended' process ended  Notice how the comment is also being printed\n Using the -x flag:\n$ bash -x script1 + echo 'process started' process started + ls non-existing ls: cannot access 'non-existing': No such file or directory + sleep 10 + touch somefile + ls -l somefile -rw-rw-r-- 1 vagrant vagrant 0 Nov 24 23:08 somefile + echo 'process ended' process ended  It shows every line being executed. Also arguably more readable than a plain -v. Notice how the comment is being ignored\n "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/decision-making/",
	"title": "Decision Making",
	"tags": [],
	"description": "",
	"content": " Making decisions help our scripts to have better flow control and add additionally robustness and avoid repetition.\nInline syntax This syntax is composed of two operators: and (\u0026amp;\u0026amp;) and or ||\nAnd (\u0026amp;\u0026amp;) case Run a command and run another one if the former was successful:\n$ ls \u0026amp;\u0026amp; echo 'yay, command was successful' combined-output long-time newerr output somefile error_output myfile newoutput script1  As shown before, of course we can redirect stdout of the former command:\n$ ls 1\u0026gt;/dev/null \u0026amp;\u0026amp; echo 'yay, command was successful' yay, command was successful  redirecting to /dev/null basically means that we\u0026rsquo;re discarding the output\n Or (||) case Run a command and run another one if the former failed:\n$ ls /nonexistent || echo 'partition /nonexistent does not exist' ls: cannot access '/nonexistent': No such file or directory partition /nonexistent does not exist  As shown before, of course we can redirect stderr of the former command:\n$ ls /nonexistent 2\u0026gt;/dev/null || echo 'partition /nonexistent does not exist' partition /nonexistent does not exist  Combining \u0026amp;\u0026amp; and || Sometimes is useful to run a command when another one is successful, and another one when it fails.\nFor example consider the following command:\n$ cd /tmp \u0026amp;\u0026amp; echo 'command succeeded, removing old files' || echo 'command failed, aborting' command succedded  In case it succeeds we could perform some housekeeping operation and remove old logs. On the other hand if the command failed we would most likely want to abort and exit\nOf course at this point we have only echoes so nothing is actually done. If we were to perform this sort of housekeeping using these operators it would be something similar to:\n Case of success\n$ cd /tmp \u0026amp;\u0026amp; { echo 'command succeeded, removing old files' \u0026amp;\u0026amp; find -type f -mtime +2 -delete \u0026amp;\u0026amp; echo 'files removed';} || { echo 'command failed, aborting';} command succeeded, removing old files files removed  Case of failure\n$ cd /tmp2 \u0026amp;\u0026amp; { echo 'command succeeded, removing old files' \u0026amp;\u0026amp; find -type f -mtime +2 -delete \u0026amp;\u0026amp; echo 'files removed';} || echo 'command failed, aborting' -bash: cd: /tmp2: No such file or directory command failed, aborting   As you can see to perform this operation, things start to get fiddly. In order to group decisions we would need to envelop them in curly braces, and to make things worse, the closing curly brace must have a semicolon just before. Please do not use this as a reference to write long bash scripts. Your future self will appreciate when you have to change and old script without all these conditions in it.\n The command find -type f -mtime +2 -delete means: find files only with more than 2 days older and delete them\n Extended syntax Using last example as a reference, let\u0026rsquo;s refactor using an if statement:\nif cd /tmp then echo 'command succeeded, removing old files' if find -type f -mtime +2 -delete; then echo 'files removed' else echo 'files failed to remove' fi else echo 'command failed, aborting' fi command succeeded, removing old files files removed  A couple of things to notice here:\n the first line of the if statement can have the then next, provided that it\u0026rsquo;s specified as a separate command (using semicolon) syntax is super clear and easier to maintain there is a bit of repetition in the case of failure After the then we don\u0026rsquo;t really need a newline or separator, so this would work just fine: if CONDITION; then echo 'something; fi  Using the syntax if TEST; then as an example. What goes in between if and then is called a \u0026lsquo;test command\u0026rsquo;. The amount of test commands in Bash could be intimidating at first, but once you get the hang of it, they make a lot of sense and are easy to remember. A list of those can be found in here.\nAs an extended example here\u0026rsquo;s how to ask for another condition just before the default else:\nif cd /tmp2 then echo 'command succeeded, removing old files' if find -type f -mtime +2 -delete; then echo 'files removed' else echo 'files failed to remove' fi elif cd /tmp then echo 'second command succeeded' else echo 'command failed, aborting' fi -bash: cd: /tmp2: No such file or directory second command succeeded  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/basics/success-or-failure/",
	"title": "Success of Failure",
	"tags": [],
	"description": "",
	"content": " In previous examples we\u0026rsquo;ve referred to \u0026lsquo;success\u0026rsquo; or \u0026lsquo;failure\u0026rsquo; when running commands within bash. This is closely related to the return codes of the programs we call in our commands. To find what was the return code of a particular program, just access the magic variable $? after invoking the program.\nFor this section create a file named return-codes and put the following content it in:\nif [ $1 == 'success' ] then echo 'success' exit 0 else echo 'failure' \u0026gt;\u0026amp;2 exit 1 fi  The $1 is making reference to the first argument passed to the bash script at invocation\n What is \u0026lsquo;success\u0026rsquo; then? It\u0026rsquo;s when a program returns a return code of 0.\nFor example:\n$ echo hi there hi there $ echo $? 0  Now using our little script:\n$ bash return-codes success success $ echo $? 0  And what about \u0026lsquo;failure\u0026rsquo;? It\u0026rsquo;s when a program returns a non-zero return code.\nFor example:\n$ ls non-existent ls: cannot access 'non-existent': No such file or directory $ echo $? 2  And using our script:\n$ bash return-codes fail fail $ echo $? 1  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/",
	"title": "Bash notes",
	"tags": [],
	"description": "",
	"content": " Bash notes This will be a set of notes related to GNU bash. By no means this will be a complete showcase of all the features bash has to offer, however I will be updating this documentation from time to time to make it as more accurate as possible.\nContribute to this documentation Feel free to update this content, just click the Edit this page link displayed on top right of each page, and pullrequest it. Similarly if you want to indicate some changes, feel free to open an issue about it.\n"
},
{
	"uri": "https://kajahno.me/bash-notes/en/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://kajahno.me/bash-notes/en/credits/",
	"title": "Credits",
	"tags": [],
	"description": "",
	"content": " Site generator  Hugo Hugo Theme Learn  "
},
{
	"uri": "https://kajahno.me/bash-notes/en/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]